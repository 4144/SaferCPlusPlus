<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>SaferCPlusPlus by duneroadrunner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">SaferCPlusPlus</h1>
      <h2 class="project-tagline">Home of the high performance smart pointer.</h2>
      <a href="https://github.com/duneroadrunner/SaferCPlusPlus" class="btn">View on GitHub</a>
      <a href="https://github.com/duneroadrunner/SaferCPlusPlus/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/duneroadrunner/SaferCPlusPlus/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>Feb 2016</p>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h3>

<p>A collection of safe data types that are compatible with, and can substitute for, common unsafe native c++ types. Currently these include:</p>

<ul>
<li><p>A <a href="#simple-benchmarks">fast</a>, <a href="#registered-pointers">safe replacement for native pointers</a> that, unlike std::shared_ptr for example, does not take ownership of the target (and so can point to objects on the stack).</p></li>
<li><p>An almost completely <a href="#vector">safe implementation</a> of std::vector&lt;&gt; - bounds checked, iterator checked and memory managed.</p></li>
<li><p>A couple of <a href="#vectors">other</a> highly compatible vectors that address the issue of unnecessary iterator invalidation upon insert, erase or reallocation</p></li>
<li><p><a href="#primitives">replacements</a> for the native "int", "size_t" and "bool" types that have default initialization values and address the "signed-unsigned mismatch" issues.</p></li>
</ul>

<p>Tested with msvc2013 and g++4.8 (as of Dec 2015) and msvc2010 (as of Jan 2015).</p>

<p>See the file <a href="https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_blurb.pdf">msetl_blurb.pdf</a> for more info. Or just have a look at <a href="https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example.cpp">msetl_example.cpp</a> to see the library in action.</p>

<h3>
<a id="use-cases" class="anchor" href="#use-cases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use cases</h3>

<p>This library is appropriate for use by two groups of C++ developers - those for whom safety and security are critical, and also everybody else.<br>
This library can help eliminate a lot of the opportunities for inadvertently accessing invalid memory or using uninitialized values. It essentially gets you a lot of the safety that you might get from, say Java, while retaining all of the power and most of the performance of C++.<br>
While using the library may sometimes cost a modest performance penalty, because the library elements are largely compatible with their native counterparts it's easy to, for example, "enable" the library in debug mode to help catch bugs, and "disable" it in release mode, thereby incurring no performance penalty.<br>
So there is really no excuse for not using the library in pretty much any situation.</p>

<h3>
<a id="setup-and-dependencies" class="anchor" href="#setup-and-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setup and dependencies</h3>

<p>The beauty of the library is that it is so small and simple. Using the library generally involves copying the include files you want to use into your project, and that's it. Three header files - "mseprimitives.h", "mseregistered.h" and "msemstdvector.h" - will cover most use cases. Outside of the stl, there are no other dependencies.</p>

<h3>
<a id="registered-pointers" class="anchor" href="#registered-pointers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Registered pointers</h3>

<p>"Registered" pointers are intended to behave just like native C++ pointers, except that their value is (automatically) set to nullptr when the target object is destroyed. And by default they will throw an exception upon any attempt to dereference a nullptr. Because they don't take ownership like some other smart pointers, they can point to objects allocated on the stack as well as the heap. In most cases, they can be used as a compatible, direct substitute for native pointers, making it straightforward to update legacy code (to be safer).</p>

<p>Registered pointers come in two flavors - <a href="#tregisteredpointer">TRegisteredPointer</a> and <a href="#tregisteredpointerforlegacy">TRegisteredPointerForLegacy</a>. They are both very similar. TRegisteredPointer emphasizes speed and safety a bit more, while TRegisteredPointerForLegacy emphasizes compatibility and flexibility a bit more. If you want to undertake the task of en masse replacement of native pointers in legacy code, or need to interact with legacy native pointer interfaces, TRegisteredPointerForLegacy may be more convenient.</p>

<p>Note that these registered pointers cannot target types that cannot act as base classes. The primitive types like int, bool, etc. cannot act as base classes. Fortunately, the library provides safer substitutes for int, bool and size_t that can act as base classes.</p>

<h3>
<a id="tregisteredpointer" class="anchor" href="#tregisteredpointer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredPointer</h3>

<p>usage example:</p>

<pre><code>#include "mseregistered.h"

int main(int argc, char* argv[]) {
    class CA {
    public:
        CA(int x) : m_x(x) {}
        int m_x;
    };

    mse::TRegisteredPointer&lt;CA&gt; a_ptr;
    CA a2_obj(2);
    {
        // mse::TRegisteredObj&lt;CA&gt; is a class publicly derived from CA

        mse::TRegisteredObj&lt;CA&gt; a_obj(1); // a_obj is entirely on the stack

        a_ptr = &amp;a_obj;
        a2_obj = (*a_ptr);
    }
    if (a_ptr) {
        assert(false);
    } else {
        try {
            a2_obj = (*a_ptr);
        }
        catch (...) {
            // expected exception
        }
    }

    a_ptr = mse::registered_new&lt;CA&gt;(3); // heap allocation
    mse::registered_delete&lt;CA&gt;(a_ptr);
}
</code></pre>

<h3>
<a id="tregisterednotnullpointer" class="anchor" href="#tregisterednotnullpointer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredNotNullPointer</h3>

<p>Same as TRegisteredPointer, but cannot be constructed to a null_ptr value.</p>

<h3>
<a id="tregisteredfixedpointer" class="anchor" href="#tregisteredfixedpointer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredFixedPointer</h3>

<p>Same as TRegisteredNotNullPointer, but cannot be re-targeted after construction. This is the recommended type to be used for safe parameter passing by reference.</p>

<p>usage example:</p>

<pre><code>#include "mseregistered.h"

int main(int argc, char* argv[]) {
    class CA {
    public:
        CA(std::string str) : m_str(str) {}
        std::string m_str;
    };

    class CB {
    public:
        static void foo(mse::TRegisteredFixedConstPointer&lt;CA&gt; input1_fc_ptr, mse::TRegisteredFixedConstPointer&lt;CA&gt; 
            input2_fc_ptr, mse::TRegisteredFixedPointer&lt;CA&gt; output_f_ptr) {
            output_f_ptr-&gt;m_str = "output from " + input1_fc_ptr-&gt;m_str + " and " + input2_fc_ptr-&gt;m_str;
            return;
        }
    };

    mse::TRegisteredObj&lt;CA&gt; in1_obj("input1");
    mse::TRegisteredPointer&lt;CA&gt; in2_reg_ptr = mse::registered_new&lt;CA&gt;("input2");
    mse::TRegisteredObj&lt;CA&gt; out_obj("");

    CB::foo(&amp;in1_obj, &amp;(*in2_reg_ptr), &amp;out_obj);

    mse::registered_delete&lt;CA&gt;(in2_reg_ptr);
}
</code></pre>

<h3>
<a id="tregisteredconstpointer-tregisterednotnullconstpointer-tregisteredfixedconstpointer" class="anchor" href="#tregisteredconstpointer-tregisterednotnullconstpointer-tregisteredfixedconstpointer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredConstPointer, TRegisteredNotNullConstPointer, TRegisteredFixedConstPointer</h3>

<p>Just the "const" version of the references.</p>

<h3>
<a id="tregisteredpointerforlegacy" class="anchor" href="#tregisteredpointerforlegacy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredPointerForLegacy</h3>

<p>usage example:</p>

<pre><code>#include "mseregisteredforlegacy.h"

int main(int argc, char* argv[]) {

    /* One case where you may need to use mse::TRegisteredPointerForLegacy&lt;&gt; even when not dealing with legacy code is when
    you need a reference to a class before it is fully defined. For example, when you have two classes that mutually
    reference each other. mse::TRegisteredPointer&lt;&gt; does not support this.
    */

    class C;

    class D {
    public:
        virtual ~D() {}
        mse::TRegisteredPointerForLegacy&lt;C&gt; m_c_ptr;
    };

    class C {
    public:
        mse::TRegisteredPointerForLegacy&lt;D&gt; m_d_ptr;
    };

    mse::TRegisteredObjForLegacy&lt;C&gt; regobjfl_c;
    mse::TRegisteredPointerForLegacy&lt;D&gt; d_ptr = mse::registered_new_for_legacy&lt;D&gt;();

    regobjfl_c.m_d_ptr = d_ptr;
    d_ptr-&gt;m_c_ptr = &amp;regobjfl_c;

    mse::registered_delete_for_legacy&lt;D&gt;(d_ptr);

}
</code></pre>

<h3>
<a id="tregisterednotnullpointerforlegacy" class="anchor" href="#tregisterednotnullpointerforlegacy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredNotNullPointerForLegacy</h3>

<h3>
<a id="tregisteredfixedpointerforlegacy" class="anchor" href="#tregisteredfixedpointerforlegacy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredFixedPointerForLegacy</h3>

<h3>
<a id="tregisteredconstpointerforlegacy-tregisterednotnullconstpointerforlegacy-tregisteredfixedconstpointerforlegacy" class="anchor" href="#tregisteredconstpointerforlegacy-tregisterednotnullconstpointerforlegacy-tregisteredfixedconstpointerforlegacy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TRegisteredConstPointerForLegacy, TRegisteredNotNullConstPointerForLegacy, TRegisteredFixedConstPointerForLegacy</h3>

<h3>
<a id="simple-benchmarks" class="anchor" href="#simple-benchmarks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple benchmarks</h3>

<h4>
<a id="allocation-deallocation-pointer-copy-and-assignment" class="anchor" href="#allocation-deallocation-pointer-copy-and-assignment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Allocation, deallocation, pointer copy and assignment:</h4>

<table>
<thead>
<tr>
<th>Pointer Type</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>mse::TRegisteredPointer (stack):</td>
<td>0.0270016 seconds.</td>
</tr>
<tr>
<td>native pointer (heap):</td>
<td>0.0490028 seconds.</td>
</tr>
<tr>
<td>mse::TRegisteredPointer (heap):</td>
<td>0.0740042 seconds.</td>
</tr>
<tr>
<td>std::shared_ptr (heap):</td>
<td>0.087005 seconds.</td>
</tr>
<tr>
<td>mse::TRegisteredPointerForLegacy (heap):</td>
<td>0.142008 seconds.</td>
</tr>
</tbody>
</table>

<h4>
<a id="dereferencing" class="anchor" href="#dereferencing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dereferencing:</h4>

<table>
<thead>
<tr>
<th>Pointer Type</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>native pointer:</td>
<td>0.0100006 seconds.</td>
</tr>
<tr>
<td>mse::TRegisteredObjForLegacy unchecked:</td>
<td>0.0130008 seconds.</td>
</tr>
<tr>
<td>mse::TRegisteredObjForLegacy (checked):</td>
<td>0.016001 seconds.</td>
</tr>
<tr>
<td>std::weak_ptr:</td>
<td>0.17701 seconds.</td>
</tr>
</tbody>
</table>

<p>platform: msvc2013/Windows7/Haswell<br>
benchmark source code: <a href="https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example.cpp">msetl_example.cpp</a></p>

<h3>
<a id="primitives" class="anchor" href="#primitives" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Primitives</h3>

<h3>
<a id="cint-csize_t-and-cbool" class="anchor" href="#cint-csize_t-and-cbool" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CInt, CSize_t and CBool</h3>

<p>usage example:</p>

<pre><code>#include "mseprimitives.h"

int main(int argc, char* argv[]) {

    mse::CInt i = 5;
    i -= 17;
    mse::CSize_t szt = 5;
    szt += 3;
    auto i2 = szt + i;
    CBool b = false;
    if (-4 == i2) {
        b = true;
    }
    if (b) {
        try {
            szt -= 20; // out of range result - this is going to throw an exception
        }
        catch (...) {
            // expected exception
        }
    }
}
</code></pre>

<h3>
<a id="vectors" class="anchor" href="#vectors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Vectors</h3>

<p>We provide three vectors - <a href="#vector">mstd::vector&lt;&gt;</a>, <a href="#msevector">msevector&lt;&gt;</a> and <a href="#ivector">ivector&lt;&gt;</a>. mstd::vector&lt;&gt; is simply an almost completely safe implementation of std::vector&lt;&gt;.
msevector&lt;&gt; is also quite safe. Not quite as safe as mstd::vector&lt;&gt;, but it requires less overhead. msevector&lt;&gt; also supports a new kind of iterator in addition to the standard vector iterator. This new iterator, called "ipointer", acts more like a list iterator. It's more intuitive, more useful, and isn't prone to being invalidated upon an insert or delete operation. If performance is of concern, msevector&lt;&gt; is probably the better choice of the three.
ivector&lt;&gt; is just as safe as mstd::vector&lt;&gt;, but drops support for the (problematic) standard vector iterators and only supports the ipointer iterators.</p>

<h3>
<a id="vector" class="anchor" href="#vector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>vector</h3>

<p>mstd::vector&lt;&gt; is simply an almost completely safe implementation of std::vector&lt;&gt;.</p>

<p>usage example:</p>

<pre><code>#include "msemstdvector.h"
#include &lt;vector&gt;

int main(int argc, char* argv[]) {

    mse::mstd::vector&lt;int&gt; mv;
    std::vector&lt;int&gt; sv;
    /* These two vectors should be completely interchangeable. The difference being that mv should throw
    an exception on any attempt to access invalid memory. */
}
</code></pre>

<h3>
<a id="msevector" class="anchor" href="#msevector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>msevector</h3>

<p>If you're willing to forego a little theoretical safety, msevector&lt;&gt; is still very safe without the overhead of memory management.<br>
In addition to the (high performance) standard vector iterator, msevector&lt;&gt; also supports a new kind of iterator, called "ipointer", that acts more like a list iterator in the sense that it points to an item rather than a position, and like a list iterator, it is not invalidated by insertions or deletions occurring elsewhere in the container, even if a "reallocation" occurs. In fact, standard vector iterators are so prone to being invalidated that for algorithms involving insertion or deletion, they can be generously considered not very useful, and more prudently considered dangerous. ipointers, aside from being safe, just make sense. Algorithms that work when applied to list iterators will work when applied to ipointers. And that's important as Bjarne famously points out, for cache coherency reasons, in most cases vectors should be used in place of lists, even when lists are conceptually more appropriate.<br>
msevector&lt;&gt; also provides a safe (bounds checked) version of the standard vector iterator.</p>

<p>usage example:</p>

<pre><code>#include "msemsevector.h"

int main(int argc, char* argv[]) {

    mse::msevector&lt;int&gt; v = { 1, 2, 3, 4 };
    mse::msevector&lt;int&gt;::ipointer ip_vit1(v);
    /*ip_vit1.set_to_beginning();*/ /* This would be redundant as ipointers are set to the beginning at initialization. */
    ip_vit1.advance(2);
    assert(3 == ip_vit1.item());
    auto ip_vit2 = v.ibegin(); /* ibegin() returns an ipointer */
    v.erase(ip_vit2); /* remove the first item */
    assert(3 == ip_vit1.item());
    ip_vit1.set_to_previous();
    assert(2 == ip_vit1.item());

    /* Btw, ipointers are compatible with stl algorithms, like any other stl iterators. */
    std::sort(v.ibegin(), v.iend());
    ip_vit1 = v.ibegin();

    /* And just to be clear, mse::msevector&lt;&gt; retains it's original (high performance) stl::vector iterators. */
    std::sort(v.begin(), v.end());

    /* mse::msevector&lt;&gt; also provides "safe" (bounds checked) versions of the original stl::vector iterators. */
    std::sort(v.ss_begin(), v.ss_end());
}
</code></pre>

<h3>
<a id="ivector" class="anchor" href="#ivector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ivector</h3>

<p>ivector is for cases when safety and correctness are higher priorities than compatibility and performance. ivector, like mstd::vector&lt;&gt;, is almost completely safe. ivector takes the further step of dropping support for the (problematic) standard vector iterator, and replacing it with <a href="#msevector">ipointer</a>.</p>

<p>usage example:</p>

<pre><code>#include "mseivector.h"

int main(int argc, char* argv[]) {

    mse::ivector&lt;int&gt; iv = { 1, 2, 3, 4 };
    std::sort(iv.begin(), iv.end());
    mse::ivector&lt;int&gt;::ipointer ivip = iv.begin();
}
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/duneroadrunner/SaferCPlusPlus">SaferCPlusPlus</a> is maintained by <a href="https://github.com/duneroadrunner">duneroadrunner</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
