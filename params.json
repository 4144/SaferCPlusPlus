{"name":"SaferCPlusPlus","tagline":"Home of the high performance smart pointer.","body":"Jan 2016\r\n\r\nA collection of safe data types that are compatible with, and can substitute for, common unsafe native c++ types. Currently these include:\r\n\r\n- A [fast](#simple-benchmarks), [safe replacement for native pointers](#registered-pointers) that, unlike std::shared_ptr for example, does not take ownership of the target (and so can point to objects on the stack).\r\n\r\n- An almost completely safe implementation of std::vector<> - bounds checked, iterator checked and memory managed.\r\n\r\n- A couple of other highly compatible vectors that address the issue of unnecessary iterator invalidation upon insert, erase or reallocation\r\n\r\n- replacements for the native \"int\", \"size_t\" and \"bool\" types that have default initialization values and address the \"signed-unsigned mismatch\" issues.\r\n\r\nTested with msvc2013 and g++4.8 (as of Dec 2015) and msvc2010 (as of Jan 2015).\r\n\r\nSee the file [msetl_blurb.pdf](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_blurb.pdf) for more info. Or just have a look at [msetl_example.cpp](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example.cpp) to see the library in action.\r\n\r\n\r\n\r\n### Registered Pointers\r\n\r\n\"Registered\" pointers are intended to behave just like native C++ pointers, except that their value is (automatically) set to nullptr when the target object is destroyed. And by default they will throw an exception upon any attempt to dereference a nullptr. Because they don't take ownership like some other smart pointers, they can point to objects allocated on the stack as well as the heap. In most cases, they can be used as a compatible, direct substitute for native pointers, making it straightforward to update legacy code (to be safer).\r\n\r\nRegistered pointers come in two flavors - TRegisteredPointer and TRegisteredPointerForLegacy. They are both very similar. TRegisteredPointer emphasizes speed and safety a bit more, while TRegisteredPointerForLegacy emphasizes compatibility and flexibility a bit more. If you want to undertake the task of en masse replacement of native pointers in legacy code, or need to interact with legacy native pointer interfaces, TRegisteredPointerForLegacy may be more convenient.\r\n\r\nNote that these registered pointers cannot target types that cannot act as base classes. The primitive types like int, bool, etc. cannot act as base classes. Fortunately, the library provides safer substitutes for int, bool and size_t that can act as base classes.\r\n\r\n\r\n### TRegisteredPointer\r\n\r\nusage example:\r\n\r\n    #include \"mseregistered.h\"\r\n    \r\n    int main(int argc, char* argv[]) {\r\n        class CA {\r\n        public:\r\n            CA(int x) : m_x(x) {}\r\n            int m_x;\r\n        };\r\n    \r\n        mse::TRegisteredPointer<CA> a_ptr;\r\n        CA a2_obj(2);\r\n        {\r\n            // mse::TRegisteredObj<CA> is a class publicly derived from CA\r\n    \r\n            mse::TRegisteredObj<CA> a_obj(1); // a_obj is entirely on the stack\r\n    \r\n            a_ptr = &a_obj;\r\n            a2_obj = (*a_ptr);\r\n        }\r\n        if (a_ptr) {\r\n            assert(false);\r\n        } else {\r\n            try {\r\n                a2_obj = (*a_ptr);\r\n            }\r\n            catch (...) {\r\n                // expected exception\r\n            }\r\n        }\r\n    \r\n        a_ptr = mse::registered_new<CA>(3); // heap allocation\r\n        mse::registered_delete<CA>(a_ptr);\r\n    }\r\n\r\n\r\n### TRegisteredNotNullPointer\r\nSame as TRegisteredPointer, but cannot be constructed to a null_ptr value.\r\n\r\n### TRegisteredFixedPointer\r\nSame as TRegisteredNotNullPointer, but cannot be re-targeted after construction. This is the recommended type to be used for safe parameter passing by reference.\r\n\r\n### TRegisteredPointerForLegacy\r\n\r\nusage example:\r\n\r\n    #include \"mseregisteredforlegacy.h\"\r\n    \r\n    int main(int argc, char* argv[]) {\r\n    \r\n        /* One case where you may need to use mse::TRegisteredPointerForLegacy<> even when not dealing with legacy code is when\r\n        you need a reference to a class before it is fully defined. For example, when you have two classes that mutually\r\n        reference each other. mse::TRegisteredPointer<> does not support this.\r\n        */\r\n    \r\n        class C;\r\n    \r\n        class D {\r\n        public:\r\n            virtual ~D() {}\r\n            mse::TRegisteredPointerForLegacy<C> m_c_ptr;\r\n        };\r\n    \r\n        class C {\r\n        public:\r\n            mse::TRegisteredPointerForLegacy<D> m_d_ptr;\r\n        };\r\n    \r\n        mse::TRegisteredObjForLegacy<C> regobjfl_c;\r\n        mse::TRegisteredPointerForLegacy<D> d_ptr = mse::registered_new_for_legacy<D>();\r\n    \r\n        regobjfl_c.m_d_ptr = d_ptr;\r\n        d_ptr->m_c_ptr = &regobjfl_c;\r\n    \r\n        mse::registered_delete_for_legacy<D>(d_ptr);\r\n    \r\n    }\r\n\r\n\r\n### TRegisteredNotNullPointerForLegacy\r\n\r\n### TRegisteredFixedPointerForLegacy\r\n\r\n  \r\n### Simple benchmarks\r\n\r\n#### Allocation, deallocation, pointer copy and assignment:\r\nPointer Type | Time\r\n------------ | ----\r\nmse::TRegisteredPointer (stack): | 0.0270016 seconds.\r\nnative pointer (heap): | 0.0490028 seconds.\r\nmse::TRegisteredPointer (heap): | 0.0740042 seconds.\r\nstd::shared_ptr (heap): | 0.087005 seconds.\r\nmse::TRegisteredPointerForLegacy (heap): | 0.142008 seconds.\r\n\r\n#### Dereferencing:\r\nPointer Type | Time\r\n------------ | ----\r\nnative pointer: | 0.0100006 seconds.\r\nmse::TRegisteredObjForLegacy unchecked: | 0.0130008 seconds.\r\nmse::TRegisteredObjForLegacy (checked): | 0.016001 seconds.\r\nstd::weak_ptr: | 0.17701 seconds.\r\n\r\nplatform: msvc2013/Windows7/Haswell  \r\nbenchmark source code: [msetl_example.cpp](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example.cpp)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}